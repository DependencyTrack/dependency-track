# Defines the number of worker threads that the event subsystem will consume.
# Events occur asynchronously and are processed by the Event subsystem. This
# value should be large enough to handle most production situations without
# introducing much delay, yet small enough not to pose additional load on an
# already resource-constrained server.
# A value of 0 will instruct Alpine to allocate 1 thread per CPU core. This
# can further be tweaked using the alpine.worker.thread.multiplier property.
#
# @category: Task Execution
# @type:     integer
# @required
alpine.worker.threads=0

# Defines a multiplier that is used to calculate the number of threads used
# by the event subsystem. This property is only used when alpine.worker.threads
# is set to 0. A machine with 4 cores and a multiplier of 4, will use (at most)
# 16 worker threads.
#
# @category: Task Execution
# @type:     integer
# @required
alpine.worker.thread.multiplier=4

# Required
# Defines the maximum duration for which Dependency-Track will wait for queued
# events and notifications to be processed when shutting down.
# During shutdown, newly dispatched events will not be accepted.
# The duration must be specified in ISO 8601 notation (https://en.wikipedia.org/wiki/ISO_8601#Durations).
alpine.worker.pool.drain.timeout.duration=PT5S

# Defines the path to the data directory. This directory will hold logs,
# keys, and any database or index files along with application-specific
# files or directories.
#
# @category: General
# @type:     string
# @required
alpine.data.directory=~/.dependency-track

# Defines the path to the secret key to be used for data encryption and decryption.
# The key will be generated upon first startup if it does not exist.
#
# @category: General
# @default:  ${alpine.data.directory}/keys/secret.key
# @example:  /var/run/secrets/secret.key
# @type:     string
# alpine.secret.key.path=

# Defines the path to the private key of the public-private key pair.
# The key will be generated upon first startup if it does not exist.
# The key pair is currently not used by Dependency-Track.
#
# @category: General
# @default:  ${alpine.data.directory}/keys/private.key
# @example:  /var/run/secrets/private.key
# @type:     string
# alpine.private.key.path=

# Defines the path to the public key of the public-private key pair.
# The key will be generated upon first startup if it does not exist.
# The key pair is currently not used by Dependency-Track.
#
# @category: General
# @default:  ${alpine.data.directory}/keys/public.key
# @example:  /var/run/secrets/public.key
# @type:     string
# alpine.public.key.path=

# Defines the prefix to be used for API keys. A maximum prefix length of 251
# characters is supported. The prefix may also be left empty.
#
# @category: General
# @type:     string
alpine.api.key.prefix=odt_

# Defines the interval (in seconds) to log general health information.
# If value equals 0, watchdog logging will be disabled.
#
# @category: General
# @hidden
alpine.watchdog.logging.interval=0

# Defines the database mode of operation.
# In server mode, the database will listen for connections from remote
# hosts. In embedded mode, the system will be more secure and slightly
# faster. External mode should be used when utilizing an external
# database server (i.e. mysql, postgresql, etc).
#
# @category:     Database
# @type:         enum
# @valid-values: [server, embedded, external]
alpine.database.mode=embedded

# Defines the TCP port to use when alpine.database.mode is set to 'server'.
#
# @category: Database
# @type:     integer
alpine.database.port=9092

# Specifies the JDBC URL to use when connecting to the database.
#
# @category: Database
# @example:  jdbc:postgresql://localhost:5432/dtrack
# @type:     string
# @required
alpine.database.url=jdbc:h2:~/.dependency-track/db;DB_CLOSE_ON_EXIT=FALSE

# Specifies the JDBC driver class to use.
#
# @category:     Database
# @type:         enum
# @valid-values: [org.h2.Driver, com.microsoft.sqlserver.jdbc.SQLServerDriver, org.postgresql.Driver, com.mysql.cj.jdbc.Driver]
# @hidden
alpine.database.driver=org.h2.Driver

# Specifies the username to use when authenticating to the database.
#
# @category: Database
# @type:     string
alpine.database.username=sa

# Specifies the password to use when authenticating to the database.
#
# @category: Database
# @type:     string
# alpine.database.password=

# Specifies a path to the file holding the database password.
# To be used as alternative to alpine.database.password.
#
# @category: Database
# @type:     string
# alpine.database.password.file=

# Specifies if the database connection pool is enabled.
#
# @category: Database
# @type:     boolean
alpine.database.pool.enabled=true

# This property controls the maximum size that the pool is allowed to reach,
# including both idle and in-use connections.
#
# @category: Database
# @type:     integer
alpine.database.pool.max.size=20

# Overwrite alpine.database.pool.max.size for the transactional connection pool.
#
# @category: Database
# @type:     integer
# alpine.database.pool.tx.max.size=

# Overwrite alpine.database.pool.max.size for the non-transactional connection pool.
#
# @category: Database
# @type:     integer
# alpine.database.pool.nontx.max.size=

# This property controls the minimum number of idle connections in the pool.
# This value should be equal to or less than alpine.database.pool.max.size.
# Warning: If the value is less than alpine.database.pool.max.size,
# alpine.database.pool.idle.timeout will have no effect.
#
# @category: Database
# @type:     integer
alpine.database.pool.min.idle=10

# Overwrite alpine.database.pool.min.idle for the transactional connection pool.
#
# @category: Database
# @type:     integer
# alpine.database.pool.tx.min.idle=

# Overwrite alpine.database.pool.min.idle for the non-transactional connection pool.
#
# @category: Database
# @type:     integer
# alpine.database.pool.nontx.min.idle=

# This property controls the maximum amount of time that a connection is
# allowed to sit idle in the pool.
#
# @category: Database
# @type:     integer
alpine.database.pool.idle.timeout=300000

# Overwrite alpine.database.pool.idle.timeout for the transactional connection pool.
#
# @category: Database
# @type:     integer
# alpine.database.pool.tx.idle.timeout=

# Overwrite alpine.database.pool.idle.timeout for the non-transactional connection pool.
#
# @category: Database
# @type:     integer
# alpine.database.pool.nontx.idle.timeout=

# This property controls the maximum lifetime of a connection in the pool.
# An in-use connection will never be retired, only when it is closed will
# it then be removed.
#
# @category: Database
# @type:     integer
alpine.database.pool.max.lifetime=600000

# Overwrite alpine.database.pool.max.lifetime for the transactional connection pool.
#
# @category: Database
# @type:     integer
# alpine.database.pool.tx.max.lifetime=

# Overwrite alpine.database.pool.max.lifetime for the non-transactional connection pool.
#
# @category: Database
# @type:     integer
# alpine.database.pool.nontx.max.lifetime=

# Controls the 2nd level cache type used by DataNucleus, the Object Relational Mapper (ORM).
# See <https://www.datanucleus.org/products/accessplatform_6_0/jdo/persistence.html#cache_level2>.
#
# Setting this property to "none" may help in reducing the memory footprint of Dependency-Track,
# but has the potential to slow down database operations.
# Size of the cache may be monitored through the "datanucleus_cache_second_level_entries" metric,
# refer to <https://docs.dependencytrack.org/getting-started/monitoring/#metrics> for details.
#
# @category:     Database
# @default:      soft
# @type:         enum
# @valid-values: [soft, weak, none]
# alpine.datanucleus.cache.level2.type=

# Specifies the number of bcrypt rounds to use when hashing a user's password.
# The higher the number the more secure the password, at the expense of
# hardware resources and additional time to generate the hash.
#
# @category: General
# @type:     integer
# @required
alpine.bcrypt.rounds=14

# Defines if LDAP will be used for user authentication. If enabled,
# `alpine.ldap.*` properties should be set accordingly.
#
# @category: LDAP
# @type:     boolean
alpine.ldap.enabled=false

# Specifies the LDAP server URL.
# <br/><br/>
# Examples (Microsoft Active Directory):
# <ul>
#   <li><code>ldap://ldap.example.com:3268</code></li>
#   <li><code>ldaps://ldap.example.com:3269</code></li>
# </ul>
# Examples (ApacheDS, Fedora 389 Directory, NetIQ/Novell eDirectory, etc):
# <ul>
#   <li><code>ldap://ldap.example.com:389</code></li>
#   <li><code>ldaps://ldap.example.com:636</code></li>
# </ul>
#
# @category: LDAP
# @type:     string
alpine.ldap.server.url=ldap://ldap.example.com:389

# Specifies the base DN that all queries should search from
#
# @category: LDAP
# @type:     string
alpine.ldap.basedn=dc=example,dc=com

# Specifies the LDAP security authentication level to use.
# If this property is empty or unspecified, the behaviour is determined by the service provider.
#
# @category:     LDAP
# @type:         enum
# @valid-values: [none, simple, strong]
alpine.ldap.security.auth=simple

# If anonymous access is not permitted, specify a username with limited access
# to the directory, just enough to perform searches. This should be the fully
# qualified DN of the user.
#
# @category: LDAP
# @type:     string
alpine.ldap.bind.username=

# If anonymous access is not permitted, specify a password for the username
# used to bind.
#
# @category: LDAP
# @type:     string
alpine.ldap.bind.password=

# Specifies if the username entered during login needs to be formatted prior
# to asserting credentials against the directory. For Active Directory, the
# userPrincipal attribute typically ends with the domain, whereas the
# samAccountName attribute and other directory server implementations do not.
# The %s variable will be substituted with the username asserted during login.
# <br/><br/>
# Example (Microsoft Active Directory):
# <ul><li><code>%s@example.com</code></li></ul>
# Example (ApacheDS, Fedora 389 Directory, NetIQ/Novell eDirectory, etc):
# <ul><li><code>%s</code></li></ul>
#
# @category: LDAP
# @type:     string
alpine.ldap.auth.username.format=%s@example.com

# Specifies the Attribute that identifies a users ID.
# <br/><br/>
# Example (Microsoft Active Directory):
# <ul><li><code>userPrincipalName</code></li></ul>
# Example (ApacheDS, Fedora 389 Directory, NetIQ/Novell eDirectory, etc):
# <ul><li><code>uid</code></li></ul>
#
# @category: LDAP
# @type:     string
alpine.ldap.attribute.name=userPrincipalName

# Specifies the LDAP attribute used to store a users email address
#
# @category: LDAP
# @type:     string
alpine.ldap.attribute.mail=mail

# Specifies the LDAP search filter used to retrieve all groups from the directory.
# <br/><br/>
# Example (Microsoft Active Directory):
# <ul><li><code>(&(objectClass=group)(objectCategory=Group))</code></li></ul>
# Example (ApacheDS, Fedora 389 Directory, NetIQ/Novell eDirectory, etc):
# <ul><li><code>(&(objectClass=groupOfUniqueNames))</code></li></ul>
#
# @category: LDAP
# @type:     string
alpine.ldap.groups.filter=(&(objectClass=group)(objectCategory=Group))

# Specifies the LDAP search filter to use to query a user and retrieve a list
# of groups the user is a member of. The `{USER_DN}` variable will be substituted
# with the actual value of the users DN at runtime.
# <br/><br/>
# Example (Microsoft Active Directory):
# <ul><li><code>(&(objectClass=group)(objectCategory=Group)(member={USER_DN}))</code></li></ul>
# Example (Microsoft Active Directory - with nested group support):
# <ul><li><code>(member:1.2.840.113556.1.4.1941:={USER_DN})</code></li></ul>
# Example (ApacheDS, Fedora 389 Directory, NetIQ/Novell eDirectory, etc):
# <ul><li><code>(&(objectClass=groupOfUniqueNames)(uniqueMember={USER_DN}))</code></li></ul>
#
# @category: LDAP
# @type:     string
alpine.ldap.user.groups.filter=(member:1.2.840.113556.1.4.1941:={USER_DN})

# Specifies the LDAP search filter used to search for groups by their name.
# The `{SEARCH_TERM}` variable will be substituted at runtime.
# <br/><br/>
# Example (Microsoft Active Directory):
# <ul><li><code>(&(objectClass=group)(objectCategory=Group)(cn=*{SEARCH_TERM}*))</code></li></ul>
# Example (ApacheDS, Fedora 389 Directory, NetIQ/Novell eDirectory, etc):
# <ul><li><code>(&(objectClass=groupOfUniqueNames)(cn=*{SEARCH_TERM}*))</code></li></ul>
#
# @category: LDAP
# @type:     string
alpine.ldap.groups.search.filter=(&(objectClass=group)(objectCategory=Group)(cn=*{SEARCH_TERM}*))

# Specifies the LDAP search filter used to search for users by their name.
# The <code>{SEARCH_TERM}</code> variable will be substituted at runtime.
# <br/><br/>
# Example (Microsoft Active Directory):
# <ul><li><code>(&(objectClass=group)(objectCategory=Group)(cn=*{SEARCH_TERM}*))</code></li></ul>
# Example (ApacheDS, Fedora 389 Directory, NetIQ/Novell eDirectory, etc):
# <ul><li><code>(&(objectClass=inetOrgPerson)(cn=*{SEARCH_TERM}*))</code></li></ul>
#
# @category: LDAP
# @type:     string
alpine.ldap.users.search.filter=(&(objectClass=user)(objectCategory=Person)(cn=*{SEARCH_TERM}*))

# Specifies if mapped LDAP accounts are automatically created upon successful
# authentication. When a user logs in with valid credentials but an account has
# not been previously provisioned, an authentication failure will be returned.
# This allows admins to control specifically which ldap users can access the
# system and which users cannot. When this value is set to true, a local ldap
# user will be created and mapped to the ldap account automatically. This
# automatic provisioning only affects authentication, not authorization.
#
# @category: LDAP
# @type:     boolean
alpine.ldap.user.provisioning=false

# This option will ensure that team memberships for LDAP users are dynamic and
# synchronized with membership of LDAP groups. When a team is mapped to an LDAP
# group, all local LDAP users will automatically be assigned to the team if
# they are a member of the group the team is mapped to. If the user is later
# removed from the LDAP group, they will also be removed from the team. This
# option provides the ability to dynamically control user permissions via an
# external directory.
#
# @category: LDAP
# @type:     boolean
alpine.ldap.team.synchronization=false

# HTTP proxy address. If set, then alpine.http.proxy.port must be set too.
#
# @category: HTTP
# @example:  proxy.example.com
# @type:     string
# alpine.http.proxy.address=

# @category: HTTP
# @example:  8888
# @type:     integer
# alpine.http.proxy.port=

# @category: HTTP
# @type:     string
# alpine.http.proxy.username=

# @category: HTTP
# @type:     string
# alpine.http.proxy.password=

# @category: HTTP
# @example:  localhost,127.0.0.1
# @type:     string
# alpine.no.proxy=

# Defines the connection timeout in seconds for outbound HTTP connections.
#
# @category: HTTP
# @type:     integer
# alpine.http.timeout.connection=30

# Defines the socket / read timeout in seconds for outbound HTTP connections.
#
# @category: HTTP
# @type:     integer
# alpine.http.timeout.socket=30

# Defines the request timeout in seconds for outbound HTTP connections.
#
# @category: HTTP
# @type:     integer
# alpine.http.timeout.pool=60

# Defines whether [Cross Origin Resource Sharing](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)
# (CORS) headers shall be included in REST API responses.
#
# @category: CORS
# @type:     boolean
# alpine.cors.enabled=true

# Controls the content of the `Access-Control-Allow-Origin` response header.
# <br/>
# Has no effect when alpine.cors.enabled is `false`.
#
# @category: CORS
# @type:     string
# alpine.cors.allow.origin=*

# Controls the content of the `Access-Control-Allow-Methods` response header.
# <br/>
# Has no effect when alpine.cors.enabled is `false`.
#
# @category: CORS
# @type:     string
# alpine.cors.allow.methods=GET POST PUT DELETE OPTIONS

# Controls the content of the `Access-Control-Allow-Headers` response header.
# <br/>
# Has no effect when alpine.cors.enabled is `false`.
#
# @category: CORS
# @type:     string
# alpine.cors.allow.headers=Origin, Content-Type, Authorization, X-Requested-With, Content-Length, Accept, Origin, X-Api-Key, X-Total-Count, *

# Controls the content of the `Access-Control-Expose-Headers` response header.
# <br/>
# Has no effect when alpine.cors.enabled is `false`.
#
# @category: CORS
# @type:     string
# alpine.cors.expose.headers=Origin, Content-Type, Authorization, X-Requested-With, Content-Length, Accept, Origin, X-Api-Key, X-Total-Count

# Controls the content of the `Access-Control-Allow-Credentials` response header.
# <br/>
# Has no effect when alpine.cors.enabled is `false`.
#
# @category: CORS
# @type:     boolean
# alpine.cors.allow.credentials=true

# Controls the content of the `Access-Control-Max-Age` response header.
# <br/>
# Has no effect when alpine.cors.enabled is `false`.
#
# @category: CORS
# @type:     integer
# alpine.cors.max.age=3600

# Defines whether Prometheus metrics will be exposed.
# If enabled, metrics will be available via the /metrics endpoint.
#
# @category: Observability
# @type:     boolean
alpine.metrics.enabled=false

# Defines the username required to access metrics.
# Has no effect when alpine.metrics.auth.password is not set.
#
# @category: Observability
# @type:     string
alpine.metrics.auth.username=

# Defines the password required to access metrics.
# Has no effect when alpine.metrics.auth.username is not set.
#
# @category: Observability
# @type:     string
alpine.metrics.auth.password=

# Defines if OpenID Connect will be used for user authentication.
# If enabled, `alpine.oidc.*` properties should be set accordingly.
#
# @category: OpenID Connect
# @type:     boolean
alpine.oidc.enabled=false

# Defines the client ID to be used for OpenID Connect.
# The client ID should be the same as the one configured for the frontend,
# and will only be used to validate ID tokens.
#
# @category: OpenID Connect
# @type:     string
alpine.oidc.client.id=

# Defines the issuer URL to be used for OpenID Connect.
# This issuer MUST support provider configuration via the `/.well-known/openid-configuration` endpoint.
# See also:
# <ul>
#   <li>https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata</li>
#   <li>https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfig</li>
# </ul>
#
# @category: OpenID Connect
# @type:     string
alpine.oidc.issuer=

# Defines the name of the claim that contains the username in the provider's userinfo endpoint.
# Common claims are `name`, `username`, `preferred_username` or `nickname`.
# See also:
# <ul>
#   <li>https://openid.net/specs/openid-connect-core-1_0.html#UserInfoResponse</li>
# </ul>
#
# @category: OpenID Connect
# @type:     string
alpine.oidc.username.claim=name

# Specifies if mapped OpenID Connect accounts are automatically created upon successful
# authentication. When a user logs in with a valid access token but an account has
# not been previously provisioned, an authentication failure will be returned.
# This allows admins to control specifically which OpenID Connect users can access the
# system and which users cannot. When this value is set to true, a local OpenID Connect
# user will be created and mapped to the OpenID Connect account automatically. This
# automatic provisioning only affects authentication, not authorization.
#
# @category: OpenID Connect
# @type:     boolean
alpine.oidc.user.provisioning=false

# This option will ensure that team memberships for OpenID Connect users are dynamic and
# synchronized with membership of OpenID Connect groups or assigned roles. When a team is
# mapped to an OpenID Connect group, all local OpenID Connect users will automatically be
# assigned to the team if they are a member of the group the team is mapped to. If the user
# is later removed from the OpenID Connect group, they will also be removed from the team. This
# option provides the ability to dynamically control user permissions via the identity provider.
# Note that team synchronization is only performed during user provisioning and after successful
# authentication.
#
# @category: OpenID Connect
# @type:     boolean
alpine.oidc.team.synchronization=false

# Defines the name of the claim that contains group memberships or role assignments in the provider's userinfo endpoint.
# The claim must be an array of strings. Most public identity providers do not support group or role management.
# When using a customizable / on-demand hosted identity provider, name, content, and inclusion in the userinfo endpoint
# will most likely need to be configured.
#
# @category: OpenID Connect
# @type:     string
alpine.oidc.teams.claim=groups

# Defines one or more team names that auto-provisioned OIDC users shall be added to.
# Multiple team names may be provided as comma-separated list.
# Has no effect when alpine.oidc.user.provisioning is false, or alpine.oidc.team.synchronization is true.
#
# @category: OpenID Connect
# @type:     string
alpine.oidc.teams.default=

# Define whether system requirement check is enabled.
#
# @category: General
# @type:     boolean
system.requirement.check.enabled=true

# Defines the size of the thread pool used to perform requests to the Snyk API in parallel.
# The thread pool will only be used when Snyk integration is enabled.
# A high number may result in quicker exceeding of API rate limits,
# while a number that is too low may result in vulnerability analyses taking longer.
#
# @category: Analyzers
# @type:     integer
snyk.thread.pool.size=10

# Defines the maximum amount of retries to perform for each request to the Snyk API.
# Retries are performed with increasing delays between attempts using an exponential backoff strategy.
# The initial duration defined in snyk.retry.backoff.initial.duration.ms will be
# multiplied with the value defined in snyk.retry.backoff.multiplier after each retry attempt,
# until the maximum duration defined in snyk.retry.backoff.max.duration.ms is reached.
#
# @category: Analyzers
# @type:     integer
snyk.retry.max.attempts=10

# Defines the multiplier for the exponential backoff retry strategy.
#
# @category: Analyzers
# @type:     integer
snyk.retry.backoff.multiplier=2

# Defines the duration in milliseconds to wait before attempting the first retry.
#
# @category: Analyzers
# @type:     integer
snyk.retry.backoff.initial.duration.ms=1000

# Defines the maximum duration in milliseconds to wait before attempting the next retry.
#
# @category: Analyzers
# @type:     integer
snyk.retry.backoff.max.duration.ms=60000

# Defines the maximum number of PURLs sent in a single request to OSS Index.
# The default value is 128.
#
# @category: Analyzers
# @type:     integer
# @hidden
ossindex.request.max.purl=128

# Defines the maximum amount of retries to perform for each request to the OSS Index API.
# Retries are performed with increasing delays between attempts using an exponential backoff strategy.
# The initial duration defined in ossindex.retry.backoff.initial.duration.ms will be
# multiplied with the value defined in ossindex.retry.backoff.multiplier after each retry attempt,
# until the maximum duration defined in ossindex.retry.backoff.max.duration.ms is reached.
#
# @category: Analyzers
# @type:     integer
ossindex.retry.max.attempts=10

# Defines the multiplier for the exponential backoff retry strategy.
#
# @category: Analyzers
# @type:     integer
ossindex.retry.backoff.multiplier=2

# Defines the maximum duration in milliseconds to wait before attempting the next retry.
#
# @category: Analyzers
# @type:     integer
ossindex.retry.backoff.max.duration.ms=600000

# Defines the maximum amount of retries to perform for each request to the Trivy API.
# Retries are performed with increasing delays between attempts using an exponential backoff strategy.
# The initial duration defined in trivy.retry.backoff.initial.duration.ms will be
# multiplied with the value defined in trivy.retry.backoff.multiplier after each retry attempt,
# until the maximum duration defined in trivy.retry.backoff.max.duration.ms is reached.
#
# @category: Analyzers
# @type:     integer
trivy.retry.max.attempts=10

# Defines the multiplier for the exponential backoff retry strategy.
#
# @category: Analyzers
# @type:     integer
trivy.retry.backoff.multiplier=2

# Defines the duration in milliseconds to wait before attempting the first retry.
#
# @category: Analyzers
# @type:     integer
trivy.retry.backoff.initial.duration.ms=1000

# Defines the maximum duration in milliseconds to wait before attempting the next retry.
#
# @category: Analyzers
# @type:     integer
trivy.retry.backoff.max.duration.ms=60000

# This flag activate the cache stampede blocker for the repository meta analyzer allowing to handle high concurrency workloads when there
# is a high ratio of duplicate components which can cause unnecessary external calls and index violation on PUBLIC.REPOSITORY_META_COMPONENT_COMPOUND_IDX during cache population.
# The default value is true.
#
# @category: Analyzers
# @type:     boolean
repo.meta.analyzer.cacheStampedeBlocker.enabled=true

# The cache stampede blocker use a striped (partitioned) lock to distribute locks across keys.
# This parameter defines the number of bucket used by the striped lock. The lock used for a given key is derived from the key hashcode and number of buckets.
# This value should be set according to your portfolio profile (i.e. number of projects and proportion of duplicates).
# Too few buckets and an unbalanced portfolio (i.e. high number of purl going to the same partition) can lead to forced serialization
# Too much buckets can lead to unnecessary memory usage. Note that the memory footprint of Striped Lock is 32 * (nbOfBuckets * 1) Bytes.
# A value between 1_000 (~32 KB) and 1_000_000 (~32 MB) seems reasonable.
# The default value is 1000 (~32KB).
#
# @category: Analyzers
# @type:     integer
repo.meta.analyzer.cacheStampedeBlocker.lock.buckets=1000

# Defines the maximum number of attempts used by Resilience4J for exponential backoff retry regarding repo meta analyzer cache loading per key.
# The default value is 10.
#
# @category: Analyzers
# @type:     integer
repo.meta.analyzer.cacheStampedeBlocker.max.attempts=10

